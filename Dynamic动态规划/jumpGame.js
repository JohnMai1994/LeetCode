// 有n块石头分别在x轴0,1,...n-1位置
// 一只青蛙在石头0，想跳到石头n-1
// 如果青蛙在第i块石头上，它最多可以向右跳距离ai
// 问青蛙能否跳到石头n-1

// 动态规划四个步骤
// 步骤1. 确定状态: 最后一步，如果请问能跳到最后一块石头n-1, 我们考虑它跳的最后一步
// 这一步是从石头 i 跳过来， i < n - 1
// 需要同时满足两个条件
// - 青蛙可以跳到石头 i
// - 最后异步不超过跳跃的最大距离: n - 1 - i <= ai

// 子问题： 我们需要知道青蛙能不能跳到石头 i (i < n - 1)
// 而我们原来要求青蛙能不能跳到石头 n - 1
// 子问题
// 状态： 设f[j]表示青蛙能不能跳到石头j


// 步骤2. 转移方程
// 设f[j]表示青蛙能不能跳到石头j
// f[j] = OR 0<=i<j (f[i] AND i + a[i] >= j)
// 青蛙能不能跳到石头j   枚举上一个跳到的石头i   青蛙能不能跳到石头i  最后一步的距离不能超过ai

// 步骤3. 初始条件和边界情况
// - 设f[j]表示青蛙能不能跳到石头j
// - 初始条件： f[0] = True, 因为青蛙一开始就在石头0

// 步骤4. 计算顺序
// - 设f[j]表示青蛙能不能跳到石头j
// - f[j] = OR 0 <= i < j (f[i] AND i + a[i] >= j)
// - 初始化f[0]=True
// - 计算f[1], f[2]... f[n-1]
// - 答案是f[n-1]
// - 时间复杂度： O(N^2)， 空间复杂度(数组大小): O(N)


function canJump(arr) {
    const n = arr.length
    let f = [true]; // initialization

    for (let j = 1; j < n ; ++j) {
        f[j] = false
        // previous stone i
        // last jump is from i to j
        for (let i = 0; i < j; i++) {
            if (f[i] && i + arr[i] >= j) {
                f[j] = true
                break;
            }
        }

    }

    return f[n-1];
}

console.log(canJump([3, 4, 1, 1, 0, 0, 5]));